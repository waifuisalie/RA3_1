# RPN Grammar Mathematical Calculations

## Terminology and Definitions

### Production Rule Components
For any production rule `A → XYZ`:
- **LHS (Left Hand Side)**: The non-terminal `A` on the left of the arrow
- **RHS (Right Hand Side)**: The sequence of symbols `XYZ` on the right of the arrow
- **Non-terminal**: A symbol that can be expanded further (uppercase names like PROGRAM, EXPR)
- **Terminal**: A symbol that cannot be expanded (actual tokens like NUMERO_REAL, +, etc.)
- **ε (Epsilon)**: The empty string, representing no symbols

### FOLLOW Dependencies and Circularity

**Important Note**: Circular dependencies in FOLLOW sets are **completely normal and expected** in grammar analysis!

#### Why Circular Dependencies Occur
**Circular dependencies** in FOLLOW sets happen when non-terminals reference each other in cycles:
- Example: FOLLOW(A) depends on FOLLOW(B), FOLLOW(B) depends on FOLLOW(C), FOLLOW(C) depends on FOLLOW(A)

#### Why This is NOT a Problem

**1. Mathematical Necessity**: In recursive grammars (which most practical grammars are), non-terminals naturally reference each other. Consider:
   - `EXPR → NUMERO_REAL AFTER_NUM`
   - `AFTER_NUM → VARIAVEL AFTER_VAR_OP`
   - `AFTER_VAR_OP → OPERATOR` where OPERATOR can appear in EXPR contexts

   This creates natural cycles where FOLLOW sets depend on each other.

**2. Theoretical Foundation**: Circular dependencies are a fundamental aspect of formal language theory:
   - They arise from the recursive nature of context-free grammars
   - They're handled by well-established mathematical techniques
   - Every compiler construction textbook covers this as standard practice

**3. Computational Solution**: Fixed-point iteration is a proven, efficient algorithm:
   - Guaranteed to converge for finite grammars
   - Produces mathematically correct results
   - Used in all production compiler generators (YACC, Bison, ANTLR, etc.)

**4. Grammar Quality Indicator**: Circular dependencies often indicate **well-structured grammars**:
   - They show proper factoring and modularity
   - They enable clean separation of concerns
   - They're typical in LL(1) and LR(1) grammars

#### What WOULD Be a Problem
- **FIRST/FIRST conflicts**: Multiple productions with overlapping FIRST sets
- **FIRST/FOLLOW conflicts**: FIRST and FOLLOW sets intersecting for nullable non-terminals
- **Infinite loops**: Grammar rules that never terminate (not our case)
- **Left recursion**: In LL parsing (avoided in our grammar design)

**Conclusion**: Circular FOLLOW dependencies are a normal computational challenge, not a grammar design flaw. They're solved by standard algorithms and indicate a properly structured recursive grammar.

### Fixed-Point Iteration
**Algorithm**:
1. Initialize all FOLLOW sets with known base values
2. Apply FOLLOW rules repeatedly
3. Continue until no changes occur (fixed-point reached)
4. The final sets are mathematically correct

## Grammar Production Rules

```
1.  PROGRAM → LINHA PROGRAM_PRIME
2.  PROGRAM_PRIME → LINHA PROGRAM_PRIME
3.  PROGRAM_PRIME → EPSILON
4.  LINHA → ABRE_PARENTESES CONTENT FECHA_PARENTESES
5.  CONTENT → NUMERO_REAL AFTER_NUM
6.  CONTENT → VARIAVEL AFTER_VAR
7.  CONTENT → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
8.  CONTENT → FOR FOR_STRUCT
9.  CONTENT → WHILE WHILE_STRUCT
10. CONTENT → IFELSE IFELSE_STRUCT
11. AFTER_NUM → NUMERO_REAL OPERATOR
12. AFTER_NUM → VARIAVEL AFTER_VAR_OP
13. AFTER_NUM → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
14. AFTER_NUM → NOT
15. AFTER_NUM → RES
16. AFTER_NUM → EPSILON
17. AFTER_VAR_OP → OPERATOR
18. AFTER_VAR_OP → EPSILON
19. AFTER_VAR → NUMERO_REAL OPERATOR
20. AFTER_VAR → VARIAVEL AFTER_VAR_OP
21. AFTER_VAR → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
22. AFTER_VAR → NOT
23. AFTER_VAR → EPSILON
24. AFTER_EXPR → NUMERO_REAL OPERATOR
25. AFTER_EXPR → VARIAVEL AFTER_VAR_OP
26. AFTER_EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
27. AFTER_EXPR → OPERATOR EXPR_CHAIN
28. AFTER_EXPR → EPSILON
29. EXPR_CHAIN → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
30. EXPR_CHAIN → EPSILON
31. EXPR → NUMERO_REAL AFTER_NUM
32. EXPR → VARIAVEL AFTER_VAR
33. EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
34. EXPR → IFELSE IFELSE_STRUCT
35. OPERATOR → ARITH_OP
36. OPERATOR → COMP_OP
37. OPERATOR → LOGIC_OP
38. ARITH_OP → SOMA
39. ARITH_OP → SUBTRACAO
40. ARITH_OP → MULTIPLICACAO
41. ARITH_OP → DIVISAO_INTEIRA
42. ARITH_OP → DIVISAO_REAL
43. ARITH_OP → RESTO
44. ARITH_OP → POTENCIA
45. COMP_OP → MENOR
46. COMP_OP → MAIOR
47. COMP_OP → IGUAL
48. COMP_OP → MENOR_IGUAL
49. COMP_OP → MAIOR_IGUAL
50. COMP_OP → DIFERENTE
51. LOGIC_OP → AND
52. LOGIC_OP → OR
53. LOGIC_OP → NOT
54. FOR_STRUCT → ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES LINHA
55. WHILE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA
56. IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA
```

## Step 1: NULLABLE Set Calculation

**Definition**: A non-terminal A is NULLABLE if A ⇒* ε

**Algorithm**: Fixed-point iteration until no changes occur.

### Iteration 0
NULLABLE = ∅

### Iteration 1
Check each production for direct ε productions:
- Rule 3: PROGRAM_PRIME → EPSILON ⟹ PROGRAM_PRIME ∈ NULLABLE
- Rule 16: AFTER_NUM → EPSILON ⟹ AFTER_NUM ∈ NULLABLE
- Rule 18: AFTER_VAR_OP → EPSILON ⟹ AFTER_VAR_OP ∈ NULLABLE
- Rule 23: AFTER_VAR → EPSILON ⟹ AFTER_VAR ∈ NULLABLE
- Rule 28: AFTER_EXPR → EPSILON ⟹ AFTER_EXPR ∈ NULLABLE
- Rule 30: EXPR_CHAIN → EPSILON ⟹ EXPR_CHAIN ∈ NULLABLE

NULLABLE = {PROGRAM_PRIME, AFTER_NUM, AFTER_VAR_OP, AFTER_VAR, AFTER_EXPR, EXPR_CHAIN}

### Iteration 2
Check if any production has all symbols on RHS already NULLABLE:
- No additional nullable non-terminals found.

NULLABLE = {PROGRAM_PRIME, AFTER_NUM, AFTER_VAR_OP, AFTER_VAR, AFTER_EXPR, EXPR_CHAIN}

**Result**: Fixed point reached. No more changes.

## Step 2: FIRST Set Calculation

**FIRST Set Rules**:
1. If A is terminal: FIRST(A) = {A}
2. For rule `A → Y₁Y₂...Yₙ`:
   - Add FIRST(Y₁) - {ε} to FIRST(A)
   - If Y₁ is NULLABLE, add FIRST(Y₂) - {ε} to FIRST(A)
   - Continue until you find non-NULLABLE symbol
   - If ALL symbols are NULLABLE, add ε to FIRST(A)

### FIRST(ARITH_OP)
Rules: 38-44: ARITH_OP → SOMA | SUBTRACAO | MULTIPLICACAO | DIVISAO_INTEIRA | DIVISAO_REAL | RESTO | POTENCIA

FIRST(ARITH_OP) = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA}

### FIRST(COMP_OP)
Rules: 45-50: COMP_OP → MENOR | MAIOR | IGUAL | MENOR_IGUAL | MAIOR_IGUAL | DIFERENTE

FIRST(COMP_OP) = {MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE}

### FIRST(LOGIC_OP)
Rules: 51-53: LOGIC_OP → AND | OR | NOT

FIRST(LOGIC_OP) = {AND, OR, NOT}

### FIRST(OPERATOR)
Rules: 35-37: OPERATOR → ARITH_OP | COMP_OP | LOGIC_OP

FIRST(OPERATOR) = FIRST(ARITH_OP) ∪ FIRST(COMP_OP) ∪ FIRST(LOGIC_OP)
                = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA, MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE, AND, OR, NOT}

### FIRST(AFTER_VAR_OP)
Rules: 17-18: AFTER_VAR_OP → OPERATOR | EPSILON

FIRST(AFTER_VAR_OP) = FIRST(OPERATOR) ∪ {ε}
                    = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA, MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE, AND, OR, NOT, ε}

### FIRST(AFTER_NUM)
Rules: 11-16: AFTER_NUM → NUMERO_REAL OPERATOR | VARIAVEL AFTER_VAR_OP | ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR | NOT | RES | EPSILON

- Rule 11: FIRST(NUMERO_REAL OPERATOR) = {NUMERO_REAL}
- Rule 12: FIRST(VARIAVEL AFTER_VAR_OP) = {VARIAVEL}
- Rule 13: FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR) = {ABRE_PARENTESES}
- Rule 14: FIRST(NOT) = {NOT}
- Rule 15: FIRST(RES) = {RES}
- Rule 16: FIRST(EPSILON) = {ε}

FIRST(AFTER_NUM) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, NOT, RES, ε}

### FIRST(AFTER_VAR)
Rules: 19-23: AFTER_VAR → NUMERO_REAL OPERATOR | VARIAVEL AFTER_VAR_OP | ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR | NOT | EPSILON

- Rule 19: FIRST(NUMERO_REAL OPERATOR) = {NUMERO_REAL}
- Rule 20: FIRST(VARIAVEL AFTER_VAR_OP) = {VARIAVEL}
- Rule 21: FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR) = {ABRE_PARENTESES}
- Rule 22: FIRST(NOT) = {NOT}
- Rule 23: FIRST(EPSILON) = {ε}

FIRST(AFTER_VAR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, NOT, ε}

### FIRST(EXPR_CHAIN)
Rules: 29-30: EXPR_CHAIN → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR | EPSILON

- Rule 29: FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Rule 30: FIRST(EPSILON) = {ε}

FIRST(EXPR_CHAIN) = {ABRE_PARENTESES, ε}

### FIRST(AFTER_EXPR)
Rules: 24-28: AFTER_EXPR → NUMERO_REAL OPERATOR | VARIAVEL AFTER_VAR_OP | ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR | OPERATOR EXPR_CHAIN | EPSILON

- Rule 24: FIRST(NUMERO_REAL OPERATOR) = {NUMERO_REAL}
- Rule 25: FIRST(VARIAVEL AFTER_VAR_OP) = {VARIAVEL}
- Rule 26: FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Rule 27: FIRST(OPERATOR EXPR_CHAIN) = FIRST(OPERATOR) = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA, MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE, AND, OR, NOT}
- Rule 28: FIRST(EPSILON) = {ε}

FIRST(AFTER_EXPR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA, MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE, AND, OR, NOT, ε}

### FIRST(FOR_STRUCT)
Rule 54: FOR_STRUCT → ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES LINHA

FIRST(FOR_STRUCT) = {ABRE_PARENTESES}

### FIRST(WHILE_STRUCT)
Rule 55: WHILE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA

FIRST(WHILE_STRUCT) = {ABRE_PARENTESES}

### FIRST(IFELSE_STRUCT)
Rule 56: IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA

FIRST(IFELSE_STRUCT) = {ABRE_PARENTESES}

### FIRST(EXPR)
Rules: 31-34: EXPR → NUMERO_REAL AFTER_NUM | VARIAVEL AFTER_VAR | ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR | IFELSE IFELSE_STRUCT

- Rule 31: FIRST(NUMERO_REAL AFTER_NUM) = {NUMERO_REAL}
- Rule 32: FIRST(VARIAVEL AFTER_VAR) = {VARIAVEL}
- Rule 33: FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Rule 34: FIRST(IFELSE IFELSE_STRUCT) = {IFELSE}

FIRST(EXPR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, IFELSE}

### FIRST(CONTENT)
Rules: 5-10: CONTENT → NUMERO_REAL AFTER_NUM | VARIAVEL AFTER_VAR | ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR | FOR FOR_STRUCT | WHILE WHILE_STRUCT | IFELSE IFELSE_STRUCT

- Rule 5: FIRST(NUMERO_REAL AFTER_NUM) = {NUMERO_REAL}
- Rule 6: FIRST(VARIAVEL AFTER_VAR) = {VARIAVEL}
- Rule 7: FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Rule 8: FIRST(FOR FOR_STRUCT) = {FOR}
- Rule 9: FIRST(WHILE WHILE_STRUCT) = {WHILE}
- Rule 10: FIRST(IFELSE IFELSE_STRUCT) = {IFELSE}

FIRST(CONTENT) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, FOR, WHILE, IFELSE}

### FIRST(LINHA)
Rule 4: LINHA → ABRE_PARENTESES CONTENT FECHA_PARENTESES

FIRST(LINHA) = {ABRE_PARENTESES}

### FIRST(PROGRAM_PRIME)
Rules: 2-3: PROGRAM_PRIME → LINHA PROGRAM_PRIME | EPSILON

- Rule 2: FIRST(LINHA PROGRAM_PRIME) = FIRST(LINHA) = {ABRE_PARENTESES}
- Rule 3: FIRST(EPSILON) = {ε}

FIRST(PROGRAM_PRIME) = {ABRE_PARENTESES, ε}

### FIRST(PROGRAM)
Rule 1: PROGRAM → LINHA PROGRAM_PRIME

FIRST(PROGRAM) = FIRST(LINHA) = {ABRE_PARENTESES}

## Step 3: FOLLOW Set Calculation

**FOLLOW Rules**:

**Rule 1**: Add $ to FOLLOW(start_symbol)

**Rule 2a**: For rule `B → αAβ`: Add FIRST(β) - {ε} to FOLLOW(A)

**Rule 2b**: For rule `B → αAβ`: If β is NULLABLE or β is empty, add FOLLOW(B) to FOLLOW(A)

### FOLLOW(PROGRAM)
**Rule 1**: PROGRAM is start symbol
FOLLOW(PROGRAM) = {$}

### FOLLOW(PROGRAM_PRIME)

**Rule 1**: PROGRAM → LINHA PROGRAM_PRIME
- B = PROGRAM, α = LINHA, A = PROGRAM_PRIME, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(PROGRAM) = {$} to FOLLOW(PROGRAM_PRIME)

**Rule 2**: PROGRAM_PRIME → LINHA PROGRAM_PRIME
- B = PROGRAM_PRIME, α = LINHA, A = PROGRAM_PRIME, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(PROGRAM_PRIME) = {$} to FOLLOW(PROGRAM_PRIME)

FOLLOW(PROGRAM_PRIME) = {$}

### FOLLOW(LINHA)

**Rule 1**: PROGRAM → LINHA PROGRAM_PRIME
- B = PROGRAM, α = ε, A = LINHA, β = PROGRAM_PRIME
- **Rule 2a**: Add FIRST(PROGRAM_PRIME) - {ε} = {ABRE_PARENTESES, ε} - {ε} = {ABRE_PARENTESES} to FOLLOW(LINHA)
- **Rule 2b**: PROGRAM_PRIME is NULLABLE → add FOLLOW(PROGRAM) = {$} to FOLLOW(LINHA)

**Rule 2**: PROGRAM_PRIME → LINHA PROGRAM_PRIME
- B = PROGRAM_PRIME, α = ε, A = LINHA, β = PROGRAM_PRIME
- **Rule 2a**: Add FIRST(PROGRAM_PRIME) - {ε} = {ABRE_PARENTESES} to FOLLOW(LINHA)
- **Rule 2b**: PROGRAM_PRIME is NULLABLE → add FOLLOW(PROGRAM_PRIME) = {$} to FOLLOW(LINHA)

**Rule 54**: FOR_STRUCT → ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES LINHA
- B = FOR_STRUCT, α = ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES, A = LINHA, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(FOR_STRUCT) to FOLLOW(LINHA)

**Rule 55**: WHILE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA
- B = WHILE_STRUCT, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = LINHA, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(WHILE_STRUCT) to FOLLOW(LINHA)

**Rule 56**: IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA
- B = IFELSE_STRUCT, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = LINHA, β = LINHA
- **Rule 2a**: Add FIRST(LINHA) = {ABRE_PARENTESES} to FOLLOW(LINHA)

- B = IFELSE_STRUCT, α = ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA, A = LINHA, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(IFELSE_STRUCT) to FOLLOW(LINHA)

FOLLOW(LINHA) = {ABRE_PARENTESES, $} ∪ FOLLOW(FOR_STRUCT) ∪ FOLLOW(WHILE_STRUCT) ∪ FOLLOW(IFELSE_STRUCT)

### FOLLOW(CONTENT)

**Rule 4**: LINHA → ABRE_PARENTESES CONTENT FECHA_PARENTESES
- B = LINHA, α = ABRE_PARENTESES, A = CONTENT, β = FECHA_PARENTESES
- **Rule 2a**: Add FIRST(FECHA_PARENTESES) = {FECHA_PARENTESES} to FOLLOW(CONTENT)

FOLLOW(CONTENT) = {FECHA_PARENTESES}

### FOLLOW(AFTER_NUM)

**Rule 5**: CONTENT → NUMERO_REAL AFTER_NUM
- B = CONTENT, α = NUMERO_REAL, A = AFTER_NUM, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(CONTENT) = {FECHA_PARENTESES} to FOLLOW(AFTER_NUM)

**Rule 31**: EXPR → NUMERO_REAL AFTER_NUM
- B = EXPR, α = NUMERO_REAL, A = AFTER_NUM, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(EXPR) to FOLLOW(AFTER_NUM)

FOLLOW(AFTER_NUM) = {FECHA_PARENTESES} ∪ FOLLOW(EXPR)

### FOLLOW(AFTER_VAR_OP)

**Rule 12**: AFTER_NUM → VARIAVEL AFTER_VAR_OP
- B = AFTER_NUM, α = VARIAVEL, A = AFTER_VAR_OP, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_NUM) to FOLLOW(AFTER_VAR_OP)

**Rule 20**: AFTER_VAR → VARIAVEL AFTER_VAR_OP
- B = AFTER_VAR, α = VARIAVEL, A = AFTER_VAR_OP, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_VAR) to FOLLOW(AFTER_VAR_OP)

**Rule 25**: AFTER_EXPR → VARIAVEL AFTER_VAR_OP
- B = AFTER_EXPR, α = VARIAVEL, A = AFTER_VAR_OP, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_EXPR) to FOLLOW(AFTER_VAR_OP)

FOLLOW(AFTER_VAR_OP) = FOLLOW(AFTER_NUM) ∪ FOLLOW(AFTER_VAR) ∪ FOLLOW(AFTER_EXPR)

### FOLLOW(AFTER_VAR)

**Rule 6**: CONTENT → VARIAVEL AFTER_VAR
- B = CONTENT, α = VARIAVEL, A = AFTER_VAR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(CONTENT) = {FECHA_PARENTESES} to FOLLOW(AFTER_VAR)

**Rule 32**: EXPR → VARIAVEL AFTER_VAR
- B = EXPR, α = VARIAVEL, A = AFTER_VAR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(EXPR) to FOLLOW(AFTER_VAR)

FOLLOW(AFTER_VAR) = {FECHA_PARENTESES} ∪ FOLLOW(EXPR)

### FOLLOW(AFTER_EXPR)

**Rule 7**: CONTENT → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = CONTENT, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = AFTER_EXPR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(CONTENT) = {FECHA_PARENTESES} to FOLLOW(AFTER_EXPR)

**Rule 26**: AFTER_EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = AFTER_EXPR, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = AFTER_EXPR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_EXPR) to FOLLOW(AFTER_EXPR)

**Rule 29**: EXPR_CHAIN → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = EXPR_CHAIN, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = AFTER_EXPR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(EXPR_CHAIN) to FOLLOW(AFTER_EXPR)

**Rule 33**: EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = EXPR, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = AFTER_EXPR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(EXPR) to FOLLOW(AFTER_EXPR)

FOLLOW(AFTER_EXPR) = {FECHA_PARENTESES} ∪ FOLLOW(AFTER_EXPR) ∪ FOLLOW(EXPR_CHAIN) ∪ FOLLOW(EXPR)

### FOLLOW(EXPR_CHAIN)

**Rule 27**: AFTER_EXPR → OPERATOR EXPR_CHAIN
- B = AFTER_EXPR, α = OPERATOR, A = EXPR_CHAIN, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_EXPR) to FOLLOW(EXPR_CHAIN)

FOLLOW(EXPR_CHAIN) = FOLLOW(AFTER_EXPR)

### FOLLOW(EXPR)

**Rule 7**: CONTENT → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = CONTENT, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES AFTER_EXPR
- **Rule 2a**: Add FIRST(FECHA_PARENTESES AFTER_EXPR) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 13**: AFTER_NUM → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
- B = AFTER_NUM, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES OPERATOR
- **Rule 2a**: Add FIRST(FECHA_PARENTESES OPERATOR) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 21**: AFTER_VAR → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
- B = AFTER_VAR, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES OPERATOR
- **Rule 2a**: Add FIRST(FECHA_PARENTESES OPERATOR) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 26**: AFTER_EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = AFTER_EXPR, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES AFTER_EXPR
- **Rule 2a**: Add FIRST(FECHA_PARENTESES AFTER_EXPR) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 29**: EXPR_CHAIN → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = EXPR_CHAIN, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES AFTER_EXPR
- **Rule 2a**: Add FIRST(FECHA_PARENTESES AFTER_EXPR) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 33**: EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- B = EXPR, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES AFTER_EXPR
- **Rule 2a**: Add FIRST(FECHA_PARENTESES AFTER_EXPR) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 55**: WHILE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA
- B = WHILE_STRUCT, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES LINHA
- **Rule 2a**: Add FIRST(FECHA_PARENTESES LINHA) = {FECHA_PARENTESES} to FOLLOW(EXPR)

**Rule 56**: IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA
- B = IFELSE_STRUCT, α = ABRE_PARENTESES, A = EXPR, β = FECHA_PARENTESES LINHA LINHA
- **Rule 2a**: Add FIRST(FECHA_PARENTESES LINHA LINHA) = {FECHA_PARENTESES} to FOLLOW(EXPR)

FOLLOW(EXPR) = {FECHA_PARENTESES}

### FOLLOW(OPERATOR)

**Rule 11**: AFTER_NUM → NUMERO_REAL OPERATOR
- B = AFTER_NUM, α = NUMERO_REAL, A = OPERATOR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_NUM) to FOLLOW(OPERATOR)

**Rule 13**: AFTER_NUM → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
- B = AFTER_NUM, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = OPERATOR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_NUM) to FOLLOW(OPERATOR)

**Rule 17**: AFTER_VAR_OP → OPERATOR
- B = AFTER_VAR_OP, α = ε, A = OPERATOR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_VAR_OP) to FOLLOW(OPERATOR)

**Rule 19**: AFTER_VAR → NUMERO_REAL OPERATOR
- B = AFTER_VAR, α = NUMERO_REAL, A = OPERATOR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_VAR) to FOLLOW(OPERATOR)

**Rule 21**: AFTER_VAR → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
- B = AFTER_VAR, α = ABRE_PARENTESES EXPR FECHA_PARENTESES, A = OPERATOR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_VAR) to FOLLOW(OPERATOR)

**Rule 24**: AFTER_EXPR → NUMERO_REAL OPERATOR
- B = AFTER_EXPR, α = NUMERO_REAL, A = OPERATOR, β = ε (empty)
- **Rule 2b**: β is empty → add FOLLOW(AFTER_EXPR) to FOLLOW(OPERATOR)

**Rule 27**: AFTER_EXPR → OPERATOR EXPR_CHAIN
- B = AFTER_EXPR, α = ε, A = OPERATOR, β = EXPR_CHAIN
- **Rule 2a**: Add FIRST(EXPR_CHAIN) - {ε} = {ABRE_PARENTESES, ε} - {ε} = {ABRE_PARENTESES} to FOLLOW(OPERATOR)
- **Rule 2b**: EXPR_CHAIN is NULLABLE → add FOLLOW(AFTER_EXPR) to FOLLOW(OPERATOR)

FOLLOW(OPERATOR) = FOLLOW(AFTER_NUM) ∪ FOLLOW(AFTER_VAR_OP) ∪ FOLLOW(AFTER_VAR) ∪ FOLLOW(AFTER_EXPR) ∪ {ABRE_PARENTESES}

### Solving FOLLOW Dependencies - Fixed-Point Iteration

**Circular Dependencies Identified:**
- FOLLOW(AFTER_NUM) ↔ FOLLOW(EXPR) ↔ FOLLOW(AFTER_VAR) ↔ FOLLOW(AFTER_EXPR) ↔ FOLLOW(EXPR_CHAIN) ↔ FOLLOW(AFTER_VAR_OP)

**Iteration 0 (Base Cases):**
- FOLLOW(PROGRAM) = {$} (start symbol)
- FOLLOW(PROGRAM_PRIME) = {$} (from Rule 2b on Rule 1)
- FOLLOW(CONTENT) = {FECHA_PARENTESES} (from Rule 2a on Rule 4)
- All others = ∅

**Iteration 1:**
Starting with known non-circular dependencies:

FOLLOW(EXPR) = {FECHA_PARENTESES} (from multiple Rule 2a applications - all result in FECHA_PARENTESES)

FOLLOW(AFTER_NUM) = {FECHA_PARENTESES} ∪ FOLLOW(EXPR) = {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} = {FECHA_PARENTESES}

FOLLOW(AFTER_VAR) = {FECHA_PARENTESES} ∪ FOLLOW(EXPR) = {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} = {FECHA_PARENTESES}

FOLLOW(AFTER_EXPR) = {FECHA_PARENTESES} ∪ FOLLOW(AFTER_EXPR) ∪ FOLLOW(EXPR_CHAIN) ∪ FOLLOW(EXPR)
                  = {FECHA_PARENTESES} ∪ ∅ ∪ ∅ ∪ {FECHA_PARENTESES} = {FECHA_PARENTESES}

FOLLOW(EXPR_CHAIN) = FOLLOW(AFTER_EXPR) = {FECHA_PARENTESES}

FOLLOW(AFTER_VAR_OP) = FOLLOW(AFTER_NUM) ∪ FOLLOW(AFTER_VAR) ∪ FOLLOW(AFTER_EXPR)
                     = {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} = {FECHA_PARENTESES}

FOLLOW(OPERATOR) = FOLLOW(AFTER_NUM) ∪ FOLLOW(AFTER_VAR_OP) ∪ FOLLOW(AFTER_VAR) ∪ FOLLOW(AFTER_EXPR) ∪ {ABRE_PARENTESES}
                 = {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} ∪ {ABRE_PARENTESES}
                 = {ABRE_PARENTESES, FECHA_PARENTESES}

**Iteration 2:**
Checking if values change:
- All FOLLOW sets remain the same as Iteration 1
- **Fixed-point reached**: No changes occurred

### Missing FOLLOW Sets Calculation

**FOLLOW(ARITH_OP), FOLLOW(COMP_OP), FOLLOW(LOGIC_OP):**
From Rules 35-37: OPERATOR → ARITH_OP | COMP_OP | LOGIC_OP
- All three inherit FOLLOW(OPERATOR) = {ABRE_PARENTESES, FECHA_PARENTESES}

**FOLLOW(FOR_STRUCT), FOLLOW(WHILE_STRUCT), FOLLOW(IFELSE_STRUCT):**
From Rules 8, 9, 10: CONTENT → FOR FOR_STRUCT | WHILE WHILE_STRUCT | IFELSE IFELSE_STRUCT
- All inherit FOLLOW(CONTENT) = {FECHA_PARENTESES}

**FOLLOW(LINHA) - Complete Analysis:**
From Rule 56: IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA
- First LINHA: FOLLOW includes FIRST(LINHA) = {ABRE_PARENTESES}
- Second LINHA: FOLLOW includes FOLLOW(IFELSE_STRUCT) = {FECHA_PARENTESES}
- From Rules 54, 55: FOR_STRUCT and WHILE_STRUCT end with LINHA → FOLLOW = {FECHA_PARENTESES}
- From Rules 1, 2: PROGRAM structures → FOLLOW = {ABRE_PARENTESES, $}

FOLLOW(LINHA) = {ABRE_PARENTESES} ∪ {FECHA_PARENTESES} ∪ {FECHA_PARENTESES} ∪ {ABRE_PARENTESES, $}
               = {ABRE_PARENTESES, FECHA_PARENTESES, $}

**Final FOLLOW Sets (Fixed-Point Solution):**
- FOLLOW(PROGRAM) = {$}
- FOLLOW(PROGRAM_PRIME) = {$}
- FOLLOW(LINHA) = {ABRE_PARENTESES, FECHA_PARENTESES, $}
- FOLLOW(CONTENT) = {FECHA_PARENTESES}
- FOLLOW(AFTER_NUM) = {FECHA_PARENTESES}
- FOLLOW(AFTER_VAR_OP) = {FECHA_PARENTESES}
- FOLLOW(AFTER_VAR) = {FECHA_PARENTESES}
- FOLLOW(AFTER_EXPR) = {FECHA_PARENTESES}
- FOLLOW(EXPR_CHAIN) = {FECHA_PARENTESES}
- FOLLOW(EXPR) = {FECHA_PARENTESES}
- FOLLOW(OPERATOR) = {ABRE_PARENTESES, FECHA_PARENTESES}
- FOLLOW(ARITH_OP) = {ABRE_PARENTESES, FECHA_PARENTESES}
- FOLLOW(COMP_OP) = {ABRE_PARENTESES, FECHA_PARENTESES}
- FOLLOW(LOGIC_OP) = {ABRE_PARENTESES, FECHA_PARENTESES}
- FOLLOW(FOR_STRUCT) = {FECHA_PARENTESES}
- FOLLOW(WHILE_STRUCT) = {FECHA_PARENTESES}
- FOLLOW(IFELSE_STRUCT) = {FECHA_PARENTESES}

## Step 4: LL(1) Table Construction

**LL(1) Table Rules:**
1. For each production A → α:
   - For each terminal a ∈ FIRST(α), add A → α to TABLE[A, a]
   - If ε ∈ FIRST(α), then for each terminal b ∈ FOLLOW(A), add A → α to TABLE[A, b]

### TABLE[PROGRAM, a]
**Rule 1**: PROGRAM → LINHA PROGRAM_PRIME
- FIRST(LINHA PROGRAM_PRIME) = FIRST(LINHA) = {ABRE_PARENTESES}
- Add to TABLE[PROGRAM, ABRE_PARENTESES] = PROGRAM → LINHA PROGRAM_PRIME

### TABLE[PROGRAM_PRIME, a]
**Rule 2**: PROGRAM_PRIME → LINHA PROGRAM_PRIME
- FIRST(LINHA PROGRAM_PRIME) = {ABRE_PARENTESES}
- Add to TABLE[PROGRAM_PRIME, ABRE_PARENTESES] = PROGRAM_PRIME → LINHA PROGRAM_PRIME

**Rule 3**: PROGRAM_PRIME → EPSILON
- FIRST(EPSILON) = {ε}
- ε ∈ FIRST(EPSILON) and FOLLOW(PROGRAM_PRIME) = {$}
- Add to TABLE[PROGRAM_PRIME, $] = PROGRAM_PRIME → EPSILON

### TABLE[LINHA, a]
**Rule 4**: LINHA → ABRE_PARENTESES CONTENT FECHA_PARENTESES
- FIRST(ABRE_PARENTESES CONTENT FECHA_PARENTESES) = {ABRE_PARENTESES}
- Add to TABLE[LINHA, ABRE_PARENTESES] = LINHA → ABRE_PARENTESES CONTENT FECHA_PARENTESES

### TABLE[CONTENT, a]
**Rule 5**: CONTENT → NUMERO_REAL AFTER_NUM
- FIRST(NUMERO_REAL AFTER_NUM) = {NUMERO_REAL}
- Add to TABLE[CONTENT, NUMERO_REAL] = CONTENT → NUMERO_REAL AFTER_NUM

**Rule 6**: CONTENT → VARIAVEL AFTER_VAR
- FIRST(VARIAVEL AFTER_VAR) = {VARIAVEL}
- Add to TABLE[CONTENT, VARIAVEL] = CONTENT → VARIAVEL AFTER_VAR

**Rule 7**: CONTENT → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Add to TABLE[CONTENT, ABRE_PARENTESES] = CONTENT → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR

**Rule 8**: CONTENT → FOR FOR_STRUCT
- FIRST(FOR FOR_STRUCT) = {FOR}
- Add to TABLE[CONTENT, FOR] = CONTENT → FOR FOR_STRUCT

**Rule 9**: CONTENT → WHILE WHILE_STRUCT
- FIRST(WHILE WHILE_STRUCT) = {WHILE}
- Add to TABLE[CONTENT, WHILE] = CONTENT → WHILE WHILE_STRUCT

**Rule 10**: CONTENT → IFELSE IFELSE_STRUCT
- FIRST(IFELSE IFELSE_STRUCT) = {IFELSE}
- Add to TABLE[CONTENT, IFELSE] = CONTENT → IFELSE IFELSE_STRUCT

### TABLE[AFTER_NUM, a]
**Rule 11**: AFTER_NUM → NUMERO_REAL OPERATOR
- FIRST(NUMERO_REAL OPERATOR) = {NUMERO_REAL}
- Add to TABLE[AFTER_NUM, NUMERO_REAL] = AFTER_NUM → NUMERO_REAL OPERATOR

**Rule 12**: AFTER_NUM → VARIAVEL AFTER_VAR_OP
- FIRST(VARIAVEL AFTER_VAR_OP) = {VARIAVEL}
- Add to TABLE[AFTER_NUM, VARIAVEL] = AFTER_NUM → VARIAVEL AFTER_VAR_OP

**Rule 13**: AFTER_NUM → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR) = {ABRE_PARENTESES}
- Add to TABLE[AFTER_NUM, ABRE_PARENTESES] = AFTER_NUM → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR

**Rule 14**: AFTER_NUM → NOT
- FIRST(NOT) = {NOT}
- Add to TABLE[AFTER_NUM, NOT] = AFTER_NUM → NOT

**Rule 15**: AFTER_NUM → RES
- FIRST(RES) = {RES}
- Add to TABLE[AFTER_NUM, RES] = AFTER_NUM → RES

**Rule 16**: AFTER_NUM → EPSILON
- FIRST(EPSILON) = {ε}
- ε ∈ FIRST(EPSILON) and FOLLOW(AFTER_NUM) = {FECHA_PARENTESES}
- Add to TABLE[AFTER_NUM, FECHA_PARENTESES] = AFTER_NUM → EPSILON

### TABLE[AFTER_VAR_OP, a]
**Rule 17**: AFTER_VAR_OP → OPERATOR
- FIRST(OPERATOR) = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA, MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE, AND, OR, NOT}
- Add to TABLE[AFTER_VAR_OP, terminal] = AFTER_VAR_OP → OPERATOR for each terminal in FIRST(OPERATOR)

**Rule 18**: AFTER_VAR_OP → EPSILON
- FIRST(EPSILON) = {ε}
- ε ∈ FIRST(EPSILON) and FOLLOW(AFTER_VAR_OP) = {FECHA_PARENTESES}
- Add to TABLE[AFTER_VAR_OP, FECHA_PARENTESES] = AFTER_VAR_OP → EPSILON

### TABLE[AFTER_VAR, a]
**Rule 19**: AFTER_VAR → NUMERO_REAL OPERATOR
- FIRST(NUMERO_REAL OPERATOR) = {NUMERO_REAL}
- Add to TABLE[AFTER_VAR, NUMERO_REAL] = AFTER_VAR → NUMERO_REAL OPERATOR

**Rule 20**: AFTER_VAR → VARIAVEL AFTER_VAR_OP
- FIRST(VARIAVEL AFTER_VAR_OP) = {VARIAVEL}
- Add to TABLE[AFTER_VAR, VARIAVEL] = AFTER_VAR → VARIAVEL AFTER_VAR_OP

**Rule 21**: AFTER_VAR → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR) = {ABRE_PARENTESES}
- Add to TABLE[AFTER_VAR, ABRE_PARENTESES] = AFTER_VAR → ABRE_PARENTESES EXPR FECHA_PARENTESES OPERATOR

**Rule 22**: AFTER_VAR → NOT
- FIRST(NOT) = {NOT}
- Add to TABLE[AFTER_VAR, NOT] = AFTER_VAR → NOT

**Rule 23**: AFTER_VAR → EPSILON
- FIRST(EPSILON) = {ε}
- ε ∈ FIRST(EPSILON) and FOLLOW(AFTER_VAR) = {FECHA_PARENTESES}
- Add to TABLE[AFTER_VAR, FECHA_PARENTESES] = AFTER_VAR → EPSILON

### TABLE[AFTER_EXPR, a]
**Rule 24**: AFTER_EXPR → NUMERO_REAL OPERATOR
- FIRST(NUMERO_REAL OPERATOR) = {NUMERO_REAL}
- Add to TABLE[AFTER_EXPR, NUMERO_REAL] = AFTER_EXPR → NUMERO_REAL OPERATOR

**Rule 25**: AFTER_EXPR → VARIAVEL AFTER_VAR_OP
- FIRST(VARIAVEL AFTER_VAR_OP) = {VARIAVEL}
- Add to TABLE[AFTER_EXPR, VARIAVEL] = AFTER_EXPR → VARIAVEL AFTER_VAR_OP

**Rule 26**: AFTER_EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Add to TABLE[AFTER_EXPR, ABRE_PARENTESES] = AFTER_EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR

**Rule 27**: AFTER_EXPR → OPERATOR EXPR_CHAIN
- FIRST(OPERATOR EXPR_CHAIN) = FIRST(OPERATOR) = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA, MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE, AND, OR, NOT}
- Add to TABLE[AFTER_EXPR, terminal] = AFTER_EXPR → OPERATOR EXPR_CHAIN for each terminal in FIRST(OPERATOR)

**Rule 28**: AFTER_EXPR → EPSILON
- FIRST(EPSILON) = {ε}
- ε ∈ FIRST(EPSILON) and FOLLOW(AFTER_EXPR) = {FECHA_PARENTESES}
- Add to TABLE[AFTER_EXPR, FECHA_PARENTESES] = AFTER_EXPR → EPSILON

### TABLE[EXPR_CHAIN, a]
**Rule 29**: EXPR_CHAIN → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Add to TABLE[EXPR_CHAIN, ABRE_PARENTESES] = EXPR_CHAIN → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR

**Rule 30**: EXPR_CHAIN → EPSILON
- FIRST(EPSILON) = {ε}
- ε ∈ FIRST(EPSILON) and FOLLOW(EXPR_CHAIN) = {FECHA_PARENTESES}
- Add to TABLE[EXPR_CHAIN, FECHA_PARENTESES] = EXPR_CHAIN → EPSILON

### TABLE[EXPR, a]
**Rule 31**: EXPR → NUMERO_REAL AFTER_NUM
- FIRST(NUMERO_REAL AFTER_NUM) = {NUMERO_REAL}
- Add to TABLE[EXPR, NUMERO_REAL] = EXPR → NUMERO_REAL AFTER_NUM

**Rule 32**: EXPR → VARIAVEL AFTER_VAR
- FIRST(VARIAVEL AFTER_VAR) = {VARIAVEL}
- Add to TABLE[EXPR, VARIAVEL] = EXPR → VARIAVEL AFTER_VAR

**Rule 33**: EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- Add to TABLE[EXPR, ABRE_PARENTESES] = EXPR → ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR

**Rule 34**: EXPR → IFELSE IFELSE_STRUCT
- FIRST(IFELSE IFELSE_STRUCT) = {IFELSE}
- Add to TABLE[EXPR, IFELSE] = EXPR → IFELSE IFELSE_STRUCT

### TABLE[OPERATOR, a]
**Rule 35**: OPERATOR → ARITH_OP
- FIRST(ARITH_OP) = {SOMA, SUBTRACAO, MULTIPLICACAO, DIVISAO_INTEIRA, DIVISAO_REAL, RESTO, POTENCIA}
- Add to TABLE[OPERATOR, terminal] = OPERATOR → ARITH_OP for each terminal in FIRST(ARITH_OP)

**Rule 36**: OPERATOR → COMP_OP
- FIRST(COMP_OP) = {MENOR, MAIOR, IGUAL, MENOR_IGUAL, MAIOR_IGUAL, DIFERENTE}
- Add to TABLE[OPERATOR, terminal] = OPERATOR → COMP_OP for each terminal in FIRST(COMP_OP)

**Rule 37**: OPERATOR → LOGIC_OP
- FIRST(LOGIC_OP) = {AND, OR, NOT}
- Add to TABLE[OPERATOR, terminal] = OPERATOR → LOGIC_OP for each terminal in FIRST(LOGIC_OP)

### TABLE[ARITH_OP, a]
**Rules 38-44**: ARITH_OP → SOMA | SUBTRACAO | MULTIPLICACAO | DIVISAO_INTEIRA | DIVISAO_REAL | RESTO | POTENCIA
- Add to TABLE[ARITH_OP, SOMA] = ARITH_OP → SOMA
- Add to TABLE[ARITH_OP, SUBTRACAO] = ARITH_OP → SUBTRACAO
- Add to TABLE[ARITH_OP, MULTIPLICACAO] = ARITH_OP → MULTIPLICACAO
- Add to TABLE[ARITH_OP, DIVISAO_INTEIRA] = ARITH_OP → DIVISAO_INTEIRA
- Add to TABLE[ARITH_OP, DIVISAO_REAL] = ARITH_OP → DIVISAO_REAL
- Add to TABLE[ARITH_OP, RESTO] = ARITH_OP → RESTO
- Add to TABLE[ARITH_OP, POTENCIA] = ARITH_OP → POTENCIA

### TABLE[COMP_OP, a]
**Rules 45-50**: COMP_OP → MENOR | MAIOR | IGUAL | MENOR_IGUAL | MAIOR_IGUAL | DIFERENTE
- Add to TABLE[COMP_OP, MENOR] = COMP_OP → MENOR
- Add to TABLE[COMP_OP, MAIOR] = COMP_OP → MAIOR
- Add to TABLE[COMP_OP, IGUAL] = COMP_OP → IGUAL
- Add to TABLE[COMP_OP, MENOR_IGUAL] = COMP_OP → MENOR_IGUAL
- Add to TABLE[COMP_OP, MAIOR_IGUAL] = COMP_OP → MAIOR_IGUAL
- Add to TABLE[COMP_OP, DIFERENTE] = COMP_OP → DIFERENTE

### TABLE[LOGIC_OP, a]
**Rules 51-53**: LOGIC_OP → AND | OR | NOT
- Add to TABLE[LOGIC_OP, AND] = LOGIC_OP → AND
- Add to TABLE[LOGIC_OP, OR] = LOGIC_OP → OR
- Add to TABLE[LOGIC_OP, NOT] = LOGIC_OP → NOT

### TABLE[FOR_STRUCT, a]
**Rule 54**: FOR_STRUCT → ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES LINHA
- FIRST(ABRE_PARENTESES...) = {ABRE_PARENTESES}
- Add to TABLE[FOR_STRUCT, ABRE_PARENTESES] = FOR_STRUCT → ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES ABRE_PARENTESES NUMERO_REAL FECHA_PARENTESES LINHA

### TABLE[WHILE_STRUCT, a]
**Rule 55**: WHILE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA) = {ABRE_PARENTESES}
- Add to TABLE[WHILE_STRUCT, ABRE_PARENTESES] = WHILE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA

### TABLE[IFELSE_STRUCT, a]
**Rule 56**: IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA) = {ABRE_PARENTESES}
- Add to TABLE[IFELSE_STRUCT, ABRE_PARENTESES] = IFELSE_STRUCT → ABRE_PARENTESES EXPR FECHA_PARENTESES LINHA LINHA

## Step 5: Conflict Analysis and LL(1) Verification

### FIRST/FIRST Conflict Check
For each non-terminal with multiple productions, verify FIRST sets are disjoint:

**CONTENT**: Rules 5-10
- FIRST(NUMERO_REAL AFTER_NUM) = {NUMERO_REAL}
- FIRST(VARIAVEL AFTER_VAR) = {VARIAVEL}
- FIRST(ABRE_PARENTESES EXPR FECHA_PARENTESES AFTER_EXPR) = {ABRE_PARENTESES}
- FIRST(FOR FOR_STRUCT) = {FOR}
- FIRST(WHILE WHILE_STRUCT) = {WHILE}
- FIRST(IFELSE IFELSE_STRUCT) = {IFELSE}
- **Result**: All disjoint ✓

**AFTER_NUM**: Rules 11-16
- {NUMERO_REAL} ∩ {VARIAVEL} ∩ {ABRE_PARENTESES} ∩ {NOT} ∩ {RES} ∩ {ε} = ∅
- **Result**: All disjoint ✓

**AFTER_VAR**: Rules 19-23
- {NUMERO_REAL} ∩ {VARIAVEL} ∩ {ABRE_PARENTESES} ∩ {NOT} ∩ {ε} = ∅
- **Result**: All disjoint ✓

**AFTER_EXPR**: Rules 24-28
- {NUMERO_REAL} ∩ {VARIAVEL} ∩ {ABRE_PARENTESES} ∩ FIRST(OPERATOR) ∩ {ε} = ∅
- **Result**: All disjoint ✓

### FIRST/FOLLOW Conflict Check
For nullable non-terminals, verify FIRST ∩ FOLLOW = ∅:

**PROGRAM_PRIME** (nullable):
- FIRST(PROGRAM_PRIME) = {ABRE_PARENTESES, ε}
- FOLLOW(PROGRAM_PRIME) = {$}
- FIRST(PROGRAM_PRIME) - {ε} ∩ FOLLOW(PROGRAM_PRIME) = {ABRE_PARENTESES} ∩ {$} = ∅ ✓

**AFTER_NUM** (nullable):
- FIRST(AFTER_NUM) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, NOT, RES, ε}
- FOLLOW(AFTER_NUM) = {FECHA_PARENTESES}
- FIRST(AFTER_NUM) - {ε} ∩ FOLLOW(AFTER_NUM) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, NOT, RES} ∩ {FECHA_PARENTESES} = ∅ ✓

**AFTER_VAR_OP** (nullable):
- FIRST(AFTER_VAR_OP) = FIRST(OPERATOR) ∪ {ε}
- FOLLOW(AFTER_VAR_OP) = {FECHA_PARENTESES}
- FIRST(AFTER_VAR_OP) - {ε} ∩ FOLLOW(AFTER_VAR_OP) = FIRST(OPERATOR) ∩ {FECHA_PARENTESES} = ∅ ✓

**AFTER_VAR** (nullable):
- FIRST(AFTER_VAR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, NOT, ε}
- FOLLOW(AFTER_VAR) = {FECHA_PARENTESES}
- FIRST(AFTER_VAR) - {ε} ∩ FOLLOW(AFTER_VAR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES, NOT} ∩ {FECHA_PARENTESES} = ∅ ✓

**AFTER_EXPR** (nullable):
- FIRST(AFTER_EXPR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES} ∪ FIRST(OPERATOR) ∪ {ε}
- FOLLOW(AFTER_EXPR) = {FECHA_PARENTESES}
- FIRST(AFTER_EXPR) - {ε} ∩ FOLLOW(AFTER_EXPR) = {NUMERO_REAL, VARIAVEL, ABRE_PARENTESES} ∪ FIRST(OPERATOR) ∩ {FECHA_PARENTESES} = ∅ ✓

**EXPR_CHAIN** (nullable):
- FIRST(EXPR_CHAIN) = {ABRE_PARENTESES, ε}
- FOLLOW(EXPR_CHAIN) = {FECHA_PARENTESES}
- FIRST(EXPR_CHAIN) - {ε} ∩ FOLLOW(EXPR_CHAIN) = {ABRE_PARENTESES} ∩ {FECHA_PARENTESES} = ∅ ✓

### LL(1) Table Validation
Each table entry contains exactly one production rule. No conflicts detected.

**Mathematical Conclusion**: The grammar is **LL(1)** and can be parsed deterministically using a predictive parser with the constructed table.